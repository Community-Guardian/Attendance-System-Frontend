frontend_development_guidelines:
  type_safety:
    backend_integration:
      - match_serializer_fields
      - api_response_types: use DjangoPaginatedResponse<T>, handle ApiErrorResponse
      - enum_synchronization: match Django model choices
      - relationship_handling: use Partial<T>, handle circular dependencies

  error_handling:
    patterns:
      - loading_states: spinners, feedback messages
      - null_safety: optional chaining, nullish coalescing
      - empty_states: meaningful messages, recovery actions
      - validation_errors: match Django REST framework format

  component_patterns:
    data_display:
      tables: loading state, empty state, search feedback, pagination
      forms: disable submit, validation feedback, maintain state

  api_integration:
    practices:
      - match_endpoints: consistent paths, query parameters
      - data_mutations: match payload structure, partial updates
      - authentication: token expiration, refresh management

  model_consistency:
    base_models: id, created_at, updated_at
    relationship_fields: use Partial<T>, handle null relations
    field_types: match Django field types

  code_organization:
    type_definitions: group interfaces, consistent naming, handle circular dependencies

  documentation:
    type_comments: document relationships, validation, complex structures

  testing:
    type_coverage: API responses, form submissions, error handling

  ui_feedback:
    toast_notifications: success, error, action feedback
    error_states: card-based displays, retry mechanisms

  navigation:
    patterns: back buttons, route guards, fallback routes, breadcrumbs

  data_fetching:
    practices: handle loading/error/empty states, pagination, search
    co_location: all fetching in page, centralize state
    query_patterns: parallel queries, pagination handling
    loading_states: unified handling, consistent UI
    error_handling: centralized, consistent UI, retry mechanism

  component_hierarchy:
    data_flow:
      page_level: fetching, state, error handling
      component_level: receive props, local UI state only

  performance:
    data_management: optimize queries, caching

  type_safety:
    page_level_types: define query types, strict prop typing

  code_structure:
    page_organization: sections, component breakdown

  example_implementation:
    page_structure: data fetching, loading/error handling, component rendering
    type_parameters: useApi<T, U> usage
    pagination_handling: internal DjangoPaginatedResponse handling

  documentation:
    required_comments: dependencies, loading/error handling, props

  typescript_practices: strict checking, proper interfaces, type guards, enums

  styling_conventions: use cn utility, consistent spacing, responsive design

  component_documentation:
    required_sections: purpose, props, examples, edge cases
