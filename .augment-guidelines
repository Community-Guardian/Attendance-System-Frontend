frontend_development_guidelines:
  type_safety:
    backend_integration:
      - match_serializer_fields:
          - reference Django serializer fields for frontend interfaces
          - example: CourseSerializer fields must match Course interface
          - check nested serializer relationships (read_only vs write_only)
      - api_response_types:
          - use DjangoPaginatedResponse<T> for list endpoints
          - handle ApiErrorResponse for error cases
          - match serializer validation error structure
      - enum_synchronization:
          - match Django model choices with TypeScript enums
          - example: UserRole matches backend role choices
      - relationship_handling:
          - use Partial<T> for nested relationships
          - handle circular dependencies properly
          - match many-to-many field structures

  error_handling:
    patterns:
      - loading_states: 
          - use spinners for data fetching
          - provide loading feedback messages
          - maintain consistent loading UI patterns
      - null_safety:
          - use optional chaining (?.) for nested objects
          - provide fallback values with nullish coalescing (??)
          - handle undefined/null explicitly
          - match backend nullable fields
      - empty_states:
          - show meaningful empty state messages
          - provide context-specific guidance
          - include recovery actions when applicable
      - validation_errors:
          - match Django REST framework error format
          - handle field-specific errors
          - display non_field_errors appropriately

  component_patterns:
    data_display:
      tables:
        - handle loading state with full-width spinner row
        - show empty state message when no data
        - provide search feedback when filtering
        - consistent column alignment
        - match backend pagination structure
      forms:
        - disable submit during processing
        - show validation feedback
        - maintain form state during submissions
        - clear form after successful submission
        - match backend field constraints

  api_integration:
    practices:
      - match_endpoints:
          - use consistent API service paths
          - handle query parameters correctly
          - match backend filtering options
      - data_mutations:
          - match create/update payload structure
          - handle partial updates correctly
          - validate against backend constraints
      - authentication:
          - handle token expiration
          - refresh token management
          - match backend auth requirements

  model_consistency:
    base_models:
      - include common fields:
          - id: string
          - created_at: string
          - updated_at: string
    relationship_fields:
      - match foreign key structures:
          - use Partial<T> for nested objects
          - handle null relations
          - match many-to-many patterns
    field_types:
      - match Django field types:
          - DateTimeField: string
          - BooleanField: boolean
          - IntegerField: number
          - CharField: string
          - TextField: string
          - JSONField: object
          - ForeignKey: Partial<T>
          - ManyToManyField: Partial<T>[]

  code_organization:
    type_definitions:
      - group related interfaces
      - maintain consistent naming with backend
      - document complex type relationships
      - handle circular dependencies

  documentation:
    type_comments:
      - document backend relationships
      - note validation requirements
      - explain complex type structures
      - reference related backend models

  testing:
    type_coverage:
      - test API response handling
      - validate form submissions
      - check error handling
      - verify relationship handling

  ui_feedback:
    toast_notifications:
      - success messages for completed actions
      - error messages with clear descriptions
      - action feedback for user operations
    
    error_states:
      - card-based error displays
      - retry mechanisms
      - clear error messages
      - navigation fallbacks

  navigation:
    patterns:
      - back_buttons: include for nested routes
      - route_guards: check required params
      - fallback_routes: redirect on invalid states
      - breadcrumbs: for deep navigation

  data_fetching:
    practices:
      - handle_loading_state: true
      - handle_error_state: true
      - handle_empty_state: true
      - pagination_handling: true
      - search_integration: true
      - type_safe_api_calls: true
    co_location:
      - all_data_fetching_in_page:
          - no data fetching in components
          - pass data as props to child components
          - handle all loading states at page level
          - manage error boundaries at page root
      - state_management:
          - keep all state at page level
          - use props for child components
          - avoid nested data fetching
          - centralize refetch logic

    query_patterns:
      - parallel_queries:
          - group related useQuery hooks
          - handle combined loading states
          - manage dependent data relationships
          - share error handling
      - pagination:
          - manage page state at top level
          - handle search with pagination
          - maintain scroll position
          - preserve filter states

    loading_states:
      unified_handling:
        - single loading indicator for related data
        - consistent loading UI patterns
        - prevent partial data display
        - maintain layout stability

    error_handling:
      centralized:
        - single error boundary per page
        - consistent error UI patterns
        - unified retry mechanism
        - clear error messages

  component_hierarchy:
    data_flow:
      - page_level:
          - data fetching
          - state management
          - error handling
          - loading states
      - component_level:
          - receive data via props
          - no direct API calls
          - local UI state only
          - pure rendering logic

  performance:
    data_management:
      - optimize_queries:
          - combine related requests
          - prevent waterfall requests
          - handle dependent data efficiently
      - caching:
          - utilize React Query caching
          - manage stale time
          - handle cache invalidation

  type_safety:
    page_level_types:
      - define_query_types:
          - type all API responses
          - handle loading states
          - error type definitions
      - prop_types:
          - strict typing for child components
          - avoid any type
          - document required vs optional

  code_structure:
    page_organization:
      - sections:
          - data fetching hooks
          - state definitions
          - effect handlers
          - render logic
      - component_breakdown:
          - clear separation of concerns
          - logical grouping of related UI
          - consistent prop passing

  example_implementation:
    page_structure: |
      // Data fetching at page level
      const {
        useFetchData: useFetchCourse,
        useAddItem: useAddEnrollment,
        useDeleteItem: useDeleteEnrollment,
      } = useApi<Course, Course>(ApiService.COURSE_URL)

      // Centralized loading states
      const { data: courseData, isLoading: isLoadingCourse } = useFetchCourse(1)
      const { data: enrollmentsData, isLoading: isLoadingEnrollments } = useFetchEnrollments(1)

      // Single loading handler
      if (isLoadingCourse || isLoadingEnrollments) {
        return <PageLoadingState />
      }

      // Unified error handling
      if (error) {
        return <PageErrorState error={error} onRetry={handleRetry} />
      }

      // Pass data to components
      return (
        <PageLayout>
          <CourseHeader course={courseData} />
          <EnrollmentList 
            enrollments={enrollmentsData}
            onDelete={handleDeleteEnrollment}
          />
        </PageLayout>
      )

  documentation:
    required_comments:
      - data dependencies
      - loading state handling
      - error scenarios
      - prop requirements

  typescript_practices:
    - strict_type_checking
    - proper_interface_definitions
    - type_guards_where_needed
    - enum_for_constants

  styling_conventions:
    - use_cn_utility: true
    - consistent_spacing
    - responsive_design
    - semantic_class_names

  component_documentation:
    required_sections:
      - component_purpose
      - props_interface
      - usage_examples
      - edge_cases